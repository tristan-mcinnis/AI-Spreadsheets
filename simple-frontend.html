<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Sheets</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            color: #1e293b;
            line-height: 1.5;
        }
        .container {
            width: calc(100vw - 40px);
            max-width: calc(100vw - 40px);
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid #e2e8f0;
            overflow: hidden;
            display: flex;
            height: calc(100vh - 40px);
            position: relative;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            transition: margin-right 0.3s ease;
            overflow: hidden;
            min-width: 0;
            position: relative;
        }
        /* Removed margin-right adjustment since sidebar is now fixed overlay */
        .main-content.sidebar-open {
            /* Content stays full width with fixed sidebar overlay */
        }
        .sidebar-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .sidebar-backdrop.show {
            opacity: 1;
            visibility: visible;
        }
        .sidebar {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 400px;
            height: calc(100vh - 40px);
            border-left: 1px solid #e2e8f0;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 24px;
            box-sizing: border-box;
            transform: translateX(100%);
            transition: transform 0.3s ease, opacity 0.3s ease;
            overflow-y: auto;
            z-index: 1000;
            opacity: 0;
            border-radius: 12px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
        .sidebar.show {
            transform: translateX(0);
            opacity: 1;
        }
        .header {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: white;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
            flex-wrap: nowrap;
            gap: 8px;
            min-height: 60px;
            overflow: visible;
        }
        .header h1 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: -0.025em;
            flex-shrink: 0;
        }
        .header-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
            flex-shrink: 0;
            min-width: 0;
        }
        .toolbar {
            padding: 8px 16px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            gap: 6px;
            align-items: center;
            background: #f8fafc;
            flex-wrap: wrap;
            overflow-x: auto;
            flex-shrink: 0;
            min-height: 50px;
        }
        .btn {
            padding: 6px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .btn-primary {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            color: white;
            border-color: #334155;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #334155 0%, #475569 100%);
        }
        .btn-secondary {
            background: white;
            color: #475569;
            border-color: #d1d5db;
        }
        .btn-secondary:hover {
            background: #f8fafc;
            border-color: #9ca3af;
        }
        .formula-bar {
            padding: 8px 16px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            flex-shrink: 0;
        }
        .formula-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 14px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .formula-input:focus {
            outline: none;
            border-color: #64748b;
            box-shadow: 0 0 0 3px rgba(100, 116, 139, 0.1);
        }
        .spreadsheet {
            flex: 1;
            position: relative;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin: 16px 24px 24px 24px;
            background: white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px); /* Dynamic height based on viewport */
            width: calc(100vw - 80px); /* Constrain width to force internal scrolling */
            max-width: calc(100vw - 80px);
        }
        .spreadsheet-scroll {
            flex: 1;
            overflow: auto;
            border-radius: 6px;
            /* Force scrollbars to always be visible */
            scrollbar-width: auto; /* Firefox */
            scrollbar-color: #94a3b8 #e2e8f0; /* Firefox */
            width: 100%;
            max-width: none;
        }
        .spreadsheet-scroll::-webkit-scrollbar {
            width: 16px;
            height: 16px;
        }
        .spreadsheet-scroll::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 8px;
        }
        .spreadsheet-scroll::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            min-height: 30px;
            min-width: 30px;
        }
        .spreadsheet-scroll::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .spreadsheet-scroll::-webkit-scrollbar-corner {
            background: #e2e8f0;
        }
        /* Force scrollbars to always show */
        .spreadsheet-scroll {
            overflow-x: scroll !important;
            overflow-y: scroll !important;
        }
        table {
            border-collapse: collapse;
            table-layout: fixed;
            width: 3100px; /* Width for 15 columns at 200px + row header at 50px = ~3050px */
            min-width: 3100px;
        }
        .header-table {
            position: sticky;
            top: 0;
            z-index: 20;
            background: white;
        }
        .frozen-column {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-right: 2px solid #e2e8f0;
        }
        th, td {
            border: 1px solid #f1f5f9;
            padding: 12px 16px;
            text-align: left;
            vertical-align: top;
            width: 200px;
            min-width: 200px;
            font-size: 14px;
        }
        th {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            font-weight: 600;
            font-size: 13px;
            color: #475569;
            border-bottom: 2px solid #e2e8f0;
            min-width: 200px;
        }
        .row-header {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            text-align: center;
            font-weight: 600;
            width: 50px;
            min-width: 50px;
            color: #64748b;
            font-size: 13px;
        }
        .cell {
            width: 200px;
            min-width: 200px;
            min-height: 50px;
            cursor: cell;
            position: relative;
            word-wrap: break-word;
            transition: background-color 0.15s ease;
        }
        .cell:hover {
            background-color: #f8fafc;
        }
        .cell.has-instructions {
            /* Removed blue styling - just use normal cell appearance */
        }
        .cell.has-instructions:hover {
            background-color: #f8fafc; /* Same as normal cell hover */
        }
        .cell-actions {
            position: absolute;
            top: 2px;
            right: 2px;
            display: none;
            gap: 2px;
        }
        .cell:hover .cell-actions {
            display: flex;
        }
        .cell-action-btn {
            background: rgba(51, 65, 85, 0.9);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0.8;
            transition: all 0.15s ease;
        }
        .cell-action-btn:hover {
            opacity: 1;
            background: #334155;
            transform: scale(1.05);
        }
        .scroll-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: #f5f5f5;
            border-top: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 10px;
            z-index: 10;
        }
        .scroll-btn {
            background: #ff6b35;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }
        .scroll-btn:hover {
            background: #e55a2e;
        }
        .scroll-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .scroll-indicator {
            flex: 1;
            height: 20px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }
        .scroll-track {
            height: 100%;
            width: 200%;
            background: linear-gradient(90deg, #e0e0e0 0%, #e0e0e0 50%, transparent 50%);
        }
        .cell.selected {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 2px solid #3b82f6;
        }
        .cell input {
            border: none;
            outline: none;
            width: 100%;
            height: 100%;
            padding: 4px;
            background: transparent;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 32px;
            border-radius: 12px;
            width: 450px;
            max-width: 90vw;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border: 1px solid #e2e8f0;
        }
        .error {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            color: #dc2626;
            padding: 12px 16px;
            border-radius: 8px;
            margin: 16px 24px;
            border: 1px solid #fecaca;
            font-weight: 500;
        }
        .loading {
            text-align: center;
            padding: 24px;
            color: #64748b;
            font-weight: 500;
            background: #f8fafc;
            margin: 16px 24px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        .column-header {
            position: relative;
        }
        .column-header input {
            background: transparent;
            border: none;
            font-weight: bold;
            font-size: 14px;
            width: 100%;
            text-align: center;
        }
        .instruction-template {
            padding: 12px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin: 8px 0;
            cursor: pointer;
            background: white;
            transition: all 0.2s;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .instruction-template:hover {
            background: #f8fafc;
            border-color: #0ea5e9;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .instruction-template.selected {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-color: #0ea5e9;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .column-select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            margin: 12px 0;
            background: white;
            font-size: 14px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .column-select:focus {
            outline: none;
            border-color: #64748b;
            box-shadow: 0 0 0 3px rgba(100, 116, 139, 0.1);
        }
        .sidebar h3 {
            margin-top: 0;
            color: #1e293b;
            font-weight: 600;
            font-size: 18px;
        }
        .sidebar label {
            display: block;
            margin: 16px 0 6px 0;
            font-weight: 500;
            color: #475569;
            font-size: 14px;
        }
        .sidebar input, .sidebar textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            box-sizing: border-box;
            background: white;
            font-size: 14px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .sidebar input:focus, .sidebar textarea:focus {
            outline: none;
            border-color: #64748b;
            box-shadow: 0 0 0 3px rgba(100, 116, 139, 0.1);
        }
        .sidebar textarea {
            min-height: 120px;
            resize: vertical;
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace;
        }
        .preview-box {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 12px;
            margin: 12px 0;
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Consolas, "Liberation Mono", Menlo, monospace;
            font-size: 13px;
            white-space: pre-wrap;
            color: #475569;
        }
        
        /* Search and Filter Styles */
        .search-filter-bar {
            padding: 8px 16px;
            border-bottom: 1px solid #e2e8f0;
            background: #f1f5f9;
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
            width: 100%;
            box-sizing: border-box;
            flex-shrink: 0;
            min-height: 50px;
        }
        
        .search-input-container {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
            position: relative;
            z-index: auto;
        }
        
        .search-input {
            width: 100%;
            padding: 8px 40px 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            background: white;
            box-sizing: border-box;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #0ea5e9;
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
        }
        
        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            color: #6b7280;
            font-size: 16px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .search-clear:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .search-options {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .search-option {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #6b7280;
        }
        
        .search-option input[type="checkbox"] {
            margin: 0;
        }
        
        .filter-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 350px;
            max-height: calc(100vh - 40px);
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            padding: 24px;
            z-index: 1001;
            transform: translateX(-100%);
            transition: transform 0.3s ease, opacity 0.3s ease;
            opacity: 0;
            overflow-y: auto;
        }
        
        .filter-panel.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .filter-panel h3 {
            margin: 0 0 16px 0;
            color: #1e293b;
            font-weight: 600;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .filter-close {
            background: none;
            border: none;
            cursor: pointer;
            color: #6b7280;
            font-size: 18px;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .filter-close:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .filter-group {
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .filter-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .filter-group label {
            display: block;
            margin: 0 0 8px 0;
            font-weight: 500;
            color: #475569;
            font-size: 14px;
        }
        
        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            box-sizing: border-box;
            background: white;
            font-size: 14px;
        }
        
        .filter-actions {
            display: flex;
            gap: 8px;
            margin-top: 20px;
        }
        
        .search-stats {
            font-size: 12px;
            color: #6b7280;
            margin-left: auto;
        }
        
        .highlight {
            background-color: #fef3c7;
            border-radius: 2px;
            padding: 0 2px;
        }
        
        .filtered-row {
            opacity: 0.3;
        }
        
        .matched-row {
            background-color: #f0f9ff !important;
        }
        
        /* Hierarchical Coding Visual Indicators */
        .hierarchical-coding {
            position: relative;
        }
        
        .hierarchical-high {
            border-left: 4px solid #dc2626 !important; /* Red for high-level */
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%) !important;
        }
        
        .hierarchical-mid {
            border-left: 4px solid #ea580c !important; /* Orange for mid-level */
            background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%) !important;
        }
        
        .hierarchical-low {
            border-left: 4px solid #16a34a !important; /* Green for low-level */
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%) !important;
        }
        
        .hierarchical-coding::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 0;
            height: 0;
            border-style: solid;
        }
        
        .hierarchical-high::before {
            border-width: 0 12px 12px 0;
            border-color: transparent #dc2626 transparent transparent;
        }
        
        .hierarchical-mid::before {
            border-width: 0 12px 12px 0;
            border-color: transparent #ea580c transparent transparent;
        }
        
        .hierarchical-low::before {
            border-width: 0 12px 12px 0;
            border-color: transparent #16a34a transparent transparent;
        }
        
        .spreadsheet-scroll {
            flex: 1;
            overflow: auto;
            position: relative;
            background: white;
            min-height: 0;
        }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .header {
                flex-wrap: wrap;
                min-height: 80px;
            }
            .header-buttons {
                width: 100%;
                justify-content: center;
                margin-top: 8px;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                width: calc(100vw - 20px);
                max-width: calc(100vw - 20px);
                height: calc(100vh - 20px);
                border-radius: 8px;
            }
            .header {
                padding: 8px 12px;
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
                min-height: 100px;
            }
            .header h1 {
                font-size: 16px;
                text-align: center;
            }
            .header-buttons {
                justify-content: center;
                width: 100%;
            }
            .toolbar {
                padding: 6px 12px;
                justify-content: flex-start;
                flex-wrap: wrap;
            }
            .search-filter-bar {
                padding: 6px 12px;
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            .search-input-container {
                min-width: unset;
                max-width: unset;
            }
            .search-options {
                justify-content: center;
            }
            .btn {
                padding: 6px 10px;
                font-size: 12px;
            }
        }
        
        @media (max-width: 480px) {
            .header-buttons {
                flex-direction: column;
                width: 100%;
                gap: 4px;
            }
            .btn {
                width: 100%;
                justify-content: center;
            }
            .toolbar {
                flex-direction: column;
                align-items: stretch;
                gap: 6px;
            }
            .toolbar .btn {
                width: 100%;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="header">
                <h1>ü§ñ AI Sheets</h1>
                <div class="header-buttons">
                    <button class="btn btn-secondary" onclick="addColumn()">Add Column</button>
                    <button class="btn btn-secondary" onclick="showExamples()">Examples</button>
                    <button class="btn btn-secondary" onclick="showConfig()">Config</button>
                </div>
            </div>

        <div class="toolbar">
            <select id="modelSelect" style="font-size: 13px; padding: 6px 8px;">
                <option value="gpt-4o">GPT-4o</option>
            </select>
            <button class="btn btn-secondary" onclick="clearSheet()">Clear</button>
            <button class="btn btn-secondary" onclick="loadCSV()">Load CSV</button>
            <button class="btn btn-primary" onclick="refreshAllInstructions()">Refresh</button>
            <button class="btn btn-secondary" onclick="downloadCSV()">Download</button>
            <button class="btn btn-secondary" onclick="toggleFilterPanel()">üîç Filter</button>
            <span id="selectedCell" style="font-size: 12px; color: #6b7280; margin-left: auto;">Select a cell</span>
        </div>

        <!-- Search and Filter Bar -->
        <div class="search-filter-bar">
            <div class="search-input-container">
                <input type="text" id="searchInput" class="search-input" placeholder="Search across all cells..." 
                       oninput="performSearch()" onkeydown="handleSearchKeyDown(event)">
                <button class="search-clear" onclick="clearSearch()" title="Clear search">√ó</button>
            </div>
            <div class="search-options">
                <div class="search-option">
                    <input type="checkbox" id="regexSearch" onchange="performSearch()">
                    <label for="regexSearch">Regex</label>
                </div>
                <div class="search-option">
                    <input type="checkbox" id="fuzzySearch" onchange="performSearch()">
                    <label for="fuzzySearch">Fuzzy</label>
                </div>
                <div class="search-option">
                    <input type="checkbox" id="caseSensitive" onchange="performSearch()">
                    <label for="caseSensitive">Case</label>
                </div>
            </div>
            <div class="search-stats" id="searchStats"></div>
        </div>

        <div class="formula-bar">
            <input type="text" id="formulaInput" class="formula-input" placeholder="Enter formula or value..." 
                   onkeypress="handleFormulaKeyPress(event)">
        </div>

        <!-- Hidden file input for CSV loading -->
        <input type="file" id="csvFileInput" accept=".csv" style="display: none;" onchange="handleCSVFile(event)">

        <div id="error" class="error" style="display: none;"></div>
        <div id="loading" class="loading" style="display: none;">Processing AI functions...</div>

        <div class="spreadsheet">
            <div class="scroll-nav" style="padding: 8px 16px; background: #f8fafc; border-bottom: 1px solid #e2e8f0; display: flex; gap: 8px; align-items: center;">
                <button class="btn btn-secondary" onclick="scrollHorizontal(-300)" style="padding: 4px 8px; font-size: 12px;">‚Üê Left</button>
                <button class="btn btn-secondary" onclick="scrollVertical(-200)" style="padding: 4px 8px; font-size: 12px;">‚Üë Up</button>
                <span style="font-size: 12px; color: #64748b;">Navigate:</span>
                <button class="btn btn-secondary" onclick="scrollVertical(200)" style="padding: 4px 8px; font-size: 12px;">‚Üì Down</button>
                <button class="btn btn-secondary" onclick="scrollHorizontal(300)" style="padding: 4px 8px; font-size: 12px;">Right ‚Üí</button>
            </div>
            <div class="spreadsheet-scroll" id="spreadsheetScroll">
                <table id="spreadsheetTable">
                    <thead>
                        <tr id="headerRow">
                            <th class="row-header frozen-column"></th>
                        </tr>
                    </thead>
                    <tbody id="spreadsheetBody">
                    </tbody>
                </table>
            </div>
        </div>
        </div>

        <!-- Sidebar backdrop -->
        <div id="sidebarBackdrop" class="sidebar-backdrop" onclick="closeSidebar()"></div>

        <!-- Sidebar for column instructions -->
        <div id="sidebar" class="sidebar">
            <h3>Instructions to generate cells</h3>
            
            <label for="columnNameInput">Column Name:</label>
            <input type="text" id="columnNameInput" placeholder="Enter column name">
            
            <label>Instruction Templates:</label>
            <div id="instructionTemplates">
                <div class="instruction-template" onclick="selectTemplate('translate')">
                    <strong>üåç Translate</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('extract')">
                    <strong>üîç Extract keywords from</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('summarize')">
                    <strong>üìù Summarize</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('sentiment')">
                    <strong>üòä Analyze sentiment of</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('classify')">
                    <strong>üìÇ Classify</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('entities')">
                    <strong>üë• Extract entities from</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('clean')">
                    <strong>üßπ Clean and format</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('generate')">
                    <strong>üí° Generate ideas for</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('moderate')">
                    <strong>üõ°Ô∏è Content check</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('language')">
                    <strong>üó£Ô∏è Detect language of</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('websearch')">
                    <strong>üåê Search the web for</strong> {{column}}
                </div>
                <div class="instruction-template" onclick="selectTemplate('hierarchical')">
                    <strong>üèóÔ∏è Hierarchical Coding</strong> (High ‚Üí Mid ‚Üí Low level codes)
                </div>
                <div class="instruction-template" onclick="selectTemplate('custom')">
                    <strong>‚öôÔ∏è Custom instruction</strong>
                </div>
            </div>

            <label for="sourceColumnSelect">Source Column:</label>
            <select id="sourceColumnSelect" class="column-select">
                <option value="">Select column to reference</option>
            </select>

            <!-- Hierarchical Coding Configuration -->
            <div id="hierarchicalConfig" style="display: none; margin: 16px 0; padding: 16px; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc;">
                <label style="display: block; margin-bottom: 12px; font-weight: 600; color: #1e293b;">Hierarchical Coding Setup</label>
                <p style="font-size: 12px; color: #6b7280; margin-bottom: 16px;">This will create 3 columns for hierarchical qualitative coding based on your source text.</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 16px;">
                    <div>
                        <label style="font-size: 12px; color: #475569; margin-bottom: 4px;">High-Level Code</label>
                        <input type="text" id="highLevelName" value="Theme" style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #475569; margin-bottom: 4px;">Mid-Level Code</label>
                        <input type="text" id="midLevelName" value="Category" style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                    <div>
                        <label style="font-size: 12px; color: #475569; margin-bottom: 4px;">Low-Level Code</label>
                        <input type="text" id="lowLevelName" value="Specific Code" style="width: 100%; padding: 6px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px;">
                    </div>
                </div>
                
                <div style="font-size: 11px; color: #6b7280; padding: 8px; background: white; border-radius: 4px; border: 1px solid #e2e8f0;">
                    <strong>Example:</strong> High: Health ‚Üí Mid: Nutrition ‚Üí Low: Calorie Counting
                </div>
            </div>

            <label for="customInstructionInput">Custom Instructions:</label>
            <textarea id="customInstructionInput" placeholder="Enter your custom instructions here..."></textarea>

            <label>Preview:</label>
            <div id="instructionPreview" class="preview-box">
                Select a template and source column to see preview
            </div>

            <!-- Quality Indicators Legend -->
            <div id="qualityLegend" style="display: none; margin: 16px 0; padding: 12px; border: 1px solid #e2e8f0; border-radius: 6px; background: #f8fafc; font-size: 11px;">
                <strong style="display: block; margin-bottom: 8px; color: #1e293b;">Quality Indicators:</strong>
                <div style="margin-bottom: 4px;">
                    <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #16a34a; margin-right: 6px;"></span>High Confidence
                </div>
                <div style="margin-bottom: 4px;">
                    <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #ea580c; margin-right: 6px;"></span>Medium Confidence
                </div>
                <div style="margin-bottom: 4px;">
                    <span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #dc2626; margin-right: 6px;"></span>Low Confidence
                </div>
                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e2e8f0;">
                    <strong>Evidence Strength:</strong><br>
                    ‚óè‚óè‚óè Strong | ‚óè‚óè‚óã Moderate | ‚óè‚óã‚óã Weak
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button class="btn btn-primary" onclick="applyInstructions()" style="width: 100%; margin-bottom: 10px;">Apply Instructions</button>
                <button class="btn btn-secondary" onclick="closeSidebar()" style="width: 100%;">Cancel</button>
            </div>
        </div>

        <!-- Filter Panel -->
        <div id="filterPanel" class="filter-panel">
            <h3>
                Advanced Filters
                <button class="filter-close" onclick="toggleFilterPanel()">√ó</button>
            </h3>
            
            <div class="filter-group">
                <label for="columnFilter">Filter by Column:</label>
                <select id="columnFilter" onchange="applyFilters()">
                    <option value="">All columns</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label for="rowRangeFilter">Row Range:</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="number" id="rowFromFilter" placeholder="From" min="1" onchange="applyFilters()">
                    <span>to</span>
                    <input type="number" id="rowToFilter" placeholder="To" min="1" onchange="applyFilters()">
                </div>
            </div>
            
            <div class="filter-group">
                <label for="keywordFilter">Contains Keywords:</label>
                <input type="text" id="keywordFilter" placeholder="word1, word2, word3" oninput="applyFilters()">
                <small style="color: #6b7280; font-size: 11px;">Comma-separated keywords</small>
            </div>
            
            <div class="filter-group">
                <label for="excludeFilter">Exclude Keywords:</label>
                <input type="text" id="excludeFilter" placeholder="exclude1, exclude2" oninput="applyFilters()">
                <small style="color: #6b7280; font-size: 11px;">Comma-separated keywords to exclude</small>
            </div>
            
            <div class="filter-group">
                <label for="lengthFilter">Text Length:</label>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <select id="lengthOperator" onchange="applyFilters()">
                        <option value="gt">Greater than</option>
                        <option value="lt">Less than</option>
                        <option value="eq">Equal to</option>
                    </select>
                    <input type="number" id="lengthValue" placeholder="Length" min="0" onchange="applyFilters()">
                </div>
            </div>
            
            <div class="filter-group">
                <label for="emptyFilter">Empty Cells:</label>
                <select id="emptyFilter" onchange="applyFilters()">
                    <option value="">Show all</option>
                    <option value="empty">Show only empty</option>
                    <option value="nonempty">Hide empty</option>
                </select>
            </div>
            
            <div class="filter-actions">
                <button class="btn btn-primary" onclick="applyFilters()" style="flex: 1;">Apply</button>
                <button class="btn btn-secondary" onclick="clearFilters()" style="flex: 1;">Clear</button>
            </div>
            
            <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid #f1f5f9;">
                <button class="btn btn-secondary" onclick="exportFilteredData()" style="width: 100%; margin-bottom: 8px;">Export CSV</button>
                <button class="btn btn-primary" onclick="exportToExcel()" style="width: 100%;">Export Excel (with Quality Indicators)</button>
            </div>
        </div>
    </div>

    <!-- Config Modal -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <h2>Configuration</h2>
            <div style="margin-bottom: 15px;">
                <label for="apiKeyInput">OpenAI API Key:</label>
                <input type="password" id="apiKeyInput" style="width: 100%; padding: 8px; margin-top: 5px;">
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Get your key from <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI Platform</a>
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <label for="serperKeyInput">Serper API Key (for web search):</label>
                <input type="password" id="serperKeyInput" style="width: 100%; padding: 8px; margin-top: 5px;">
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Get your key from <a href="https://serper.dev" target="_blank">Serper.dev</a>
                </div>
            </div>
            <div style="text-align: right;">
                <button class="btn btn-secondary" onclick="closeConfig()">Cancel</button>
                <button class="btn btn-primary" onclick="saveConfig()">Save</button>
            </div>
        </div>
    </div>

    <!-- Examples Modal -->
    <div id="examplesModal" class="modal">
        <div class="modal-content">
            <h2>Example Use Cases</h2>
            <div onclick="loadExample('classification')" style="padding: 10px; border: 1px solid #ddd; margin: 10px 0; cursor: pointer; border-radius: 4px;">
                <strong>Text Classification</strong><br>
                <small>Classify movie reviews as positive, negative, or neutral</small>
            </div>
            <div onclick="loadExample('extraction')" style="padding: 10px; border: 1px solid #ddd; margin: 10px 0; cursor: pointer; border-radius: 4px;">
                <strong>Named Entity Recognition</strong><br>
                <small>Extract person names from news articles</small>
            </div>
            <div onclick="loadExample('cleaning')" style="padding: 10px; border: 1px solid #ddd; margin: 10px 0; cursor: pointer; border-radius: 4px;">
                <strong>Data Cleaning</strong><br>
                <small>Clean and normalize messy data entries</small>
            </div>
            <div onclick="loadExample('entities')" style="padding: 10px; border: 1px solid #ddd; margin: 10px 0; cursor: pointer; border-radius: 4px;">
                <strong>üë• Entity Extraction</strong><br>
                <small>Extract people, organizations, and locations from text</small>
            </div>
            <div onclick="loadExample('keywords')" style="padding: 10px; border: 1px solid #ddd; margin: 10px 0; cursor: pointer; border-radius: 4px;">
                <strong>üîç Keyword Analysis</strong><br>
                <small>Extract important keywords from product descriptions</small>
            </div>
            <div onclick="loadExample('ideas')" style="padding: 10px; border: 1px solid #ddd; margin: 10px 0; cursor: pointer; border-radius: 4px;">
                <strong>üí° Idea Generation</strong><br>
                <small>Generate creative marketing ideas from product features</small>
            </div>
            <div onclick="loadExample('websearch')" style="padding: 10px; border: 1px solid #ddd; margin: 10px 0; cursor: pointer; border-radius: 4px;">
                <strong>üåê Web Search & Research</strong><br>
                <small>Search the web for latest information on any topic</small>
            </div>
            <div style="text-align: right; margin-top: 20px;">
                <button class="btn btn-secondary" onclick="closeExamples()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        let data = [];
        let selectedCell = { row: -1, col: -1 };
        let apiKey = localStorage.getItem('openai_api_key') || '';
        let serperKey = localStorage.getItem('serper_api_key') || '';
        let columnNames = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
        let columnInstructions = {};
        let hierarchicalCodeSets = {}; // Track groups of related hierarchical columns
        let cellMetadata = {}; // Store confidence, evidence, and other metadata for each cell
        let selectedTemplate = '';
        let currentEditingColumn = -1;
        
        // Search and Filter variables
        let currentSearchTerm = '';
        let searchMatches = [];
        let currentMatchIndex = -1;
        let appliedFilters = {
            column: '',
            rowFrom: null,
            rowTo: null,
            keywords: [],
            excludeKeywords: [],
            lengthOperator: '',
            lengthValue: null,
            emptyFilter: ''
        };
        let filteredRows = new Set();

        // Enhanced AI response parser with systematic validation and fallback handling
        function parseEnhancedResponse(responseText) {
            const validationLog = [];
            
            // Initialize result with fallback values
            const result = {
                content: responseText.trim(),
                confidence: 'Low',  // Conservative fallback
                evidence: 'Weak',   // Conservative fallback
                metadata: {
                    isValid: false,
                    validationIssues: [],
                    fallbackUsed: false,
                    qualityScore: 0
                }
            };
            
            try {
                // Validate input
                if (!responseText || typeof responseText !== 'string') {
                    validationLog.push('Invalid or empty response text');
                    result.metadata.validationIssues = validationLog;
                    result.metadata.fallbackUsed = true;
                    return result;
                }
                
                // Clean and normalize response
                const cleanResponse = responseText.trim().replace(/\s+/g, ' ');
                
                // Parse structured format: "Content | Confidence: High | Evidence: Strong"
                const parts = cleanResponse.split(' | ');
                
                if (parts.length >= 3) {
                    // Extract content (first part)
                    const extractedContent = parts[0].trim();
                    if (extractedContent && extractedContent.length > 0) {
                        result.content = extractedContent;
                    } else {
                        validationLog.push('Empty content extracted');
                    }
                    
                    // Extract metadata from remaining parts
                    let confidenceFound = false;
                    let evidenceFound = false;
                    
                    for (let i = 1; i < parts.length; i++) {
                        const part = parts[i].trim();
                        
                        if (part.startsWith('Confidence:')) {
                            const confidenceValue = part.replace('Confidence:', '').trim();
                            if (validateConfidenceLevel(confidenceValue)) {
                                result.confidence = confidenceValue;
                                confidenceFound = true;
                            } else {
                                validationLog.push(`Invalid confidence level: ${confidenceValue}`);
                            }
                        } else if (part.startsWith('Evidence:')) {
                            const evidenceValue = part.replace('Evidence:', '').trim();
                            if (validateEvidenceStrength(evidenceValue)) {
                                result.evidence = evidenceValue;
                                evidenceFound = true;
                            } else {
                                validationLog.push(`Invalid evidence strength: ${evidenceValue}`);
                            }
                        }
                    }
                    
                    if (!confidenceFound) validationLog.push('Confidence level not found or invalid');
                    if (!evidenceFound) validationLog.push('Evidence strength not found or invalid');
                    
                    // Check if this is a hierarchical coding response
                    if (parts[0].includes('High:') && parts[0].includes('Mid:') && parts[0].includes('Low:')) {
                        const hierarchicalValid = validateHierarchicalStructure(parts[0]);
                        if (!hierarchicalValid) {
                            validationLog.push('Invalid hierarchical coding structure');
                        }
                    }
                    
                } else {
                    // Attempt to extract confidence and evidence from unstructured format
                    validationLog.push('Response not in expected structured format, attempting fallback parsing');
                    result.metadata.fallbackUsed = true;
                    
                    // Fallback parsing for confidence
                    const confidenceMatch = cleanResponse.match(/confidence[:\s]+([^|,.\n]+)/i);
                    if (confidenceMatch && validateConfidenceLevel(confidenceMatch[1].trim())) {
                        result.confidence = confidenceMatch[1].trim();
                    }
                    
                    // Fallback parsing for evidence
                    const evidenceMatch = cleanResponse.match(/evidence[:\s]+([^|,.\n]+)/i);
                    if (evidenceMatch && validateEvidenceStrength(evidenceMatch[1].trim())) {
                        result.evidence = evidenceMatch[1].trim();
                    }
                }
                
                // Calculate quality score
                result.metadata.qualityScore = calculateQualityScore(result, validationLog);
                
                // Determine if response is valid based on quality criteria
                result.metadata.isValid = result.metadata.qualityScore >= 0.6; // 60% threshold
                
                // Log validation issues if any
                if (validationLog.length > 0) {
                    result.metadata.validationIssues = validationLog;
                    console.warn('AI Response Validation Issues:', validationLog);
                }
                
            } catch (error) {
                validationLog.push(`Parsing error: ${error.message}`);
                result.metadata.validationIssues = validationLog;
                result.metadata.fallbackUsed = true;
                console.error('Error parsing AI response:', error);
            }
            
            return result;
        }
        
        // Validate confidence level values
        function validateConfidenceLevel(value) {
            const validLevels = ['High', 'Medium', 'Low'];
            return validLevels.includes(value);
        }
        
        // Validate evidence strength values
        function validateEvidenceStrength(value) {
            const validStrengths = ['Strong', 'Moderate', 'Weak'];
            return validStrengths.includes(value);
        }
        
        // Validate hierarchical coding structure
        function validateHierarchicalStructure(content) {
            const hasHigh = content.includes('High:');
            const hasMid = content.includes('Mid:');
            const hasLow = content.includes('Low:');
            
            // Check that all three levels are present and have content after the colon
            if (hasHigh && hasMid && hasLow) {
                const highMatch = content.match(/High:\s*([^|]+)/);
                const midMatch = content.match(/Mid:\s*([^|]+)/);
                const lowMatch = content.match(/Low:\s*([^|]+)/);
                
                return highMatch && midMatch && lowMatch && 
                       highMatch[1].trim().length > 0 && 
                       midMatch[1].trim().length > 0 && 
                       lowMatch[1].trim().length > 0;
            }
            
            return false;
        }
        
        // Calculate quality score based on validation results
        function calculateQualityScore(result, validationLog) {
            let score = 1.0; // Start with perfect score
            
            // Deduct points for validation issues
            score -= validationLog.length * 0.1; // 10% per issue
            
            // Deduct points for fallback usage
            if (result.metadata.fallbackUsed) {
                score -= 0.2; // 20% penalty for fallback
            }
            
            // Bonus for high confidence and strong evidence
            if (result.confidence === 'High') score += 0.1;
            if (result.evidence === 'Strong') score += 0.1;
            
            // Penalty for low confidence or weak evidence
            if (result.confidence === 'Low') score -= 0.15;
            if (result.evidence === 'Weak') score -= 0.15;
            
            // Ensure score is between 0 and 1
            return Math.max(0, Math.min(1, score));
        }
        
        // Get confidence level color
        function getConfidenceColor(confidence) {
            switch (confidence.toLowerCase()) {
                case 'high': return '#16a34a'; // green
                case 'medium': return '#ea580c'; // orange  
                case 'low': return '#dc2626'; // red
                default: return '#6b7280'; // gray
            }
        }
        
        // Get evidence strength indicator
        function getEvidenceIndicator(evidence) {
            switch (evidence.toLowerCase()) {
                case 'strong': return '‚óè‚óè‚óè';
                case 'moderate': return '‚óè‚óè‚óã';
                case 'weak': return '‚óè‚óã‚óã';
                default: return '‚óã‚óã‚óã';
            }
        }

        // Initialize spreadsheet
        function initSpreadsheet() {
            data = Array(30).fill().map(() => Array(15).fill(''));
            
            // Add some test data for search testing
            data[0][0] = 'Sarah';
            data[0][1] = 'I absolutely love my new iPhone 15! The camera quality is incredible.';
            data[1][0] = 'Mike';
            data[1][1] = 'Nike shoes are great for running and jogging every morning.';
            data[2][0] = 'Jennifer';
            data[2][1] = 'Had coffee at Starbucks today - it was fantastic as always.';
            data[3][0] = 'David';
            data[3][1] = 'Amazon Prime delivery is absolutely broken! My package was delayed.';
            
            renderSpreadsheet();
            initializeFilterPanel();
        }

        // Search and Filter Functions
        function performSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchTerm = searchInput.value.trim();
            const isRegex = document.getElementById('regexSearch').checked;
            const isFuzzy = document.getElementById('fuzzySearch').checked;
            const isCaseSensitive = document.getElementById('caseSensitive').checked;
            
            console.log('Performing search for:', searchTerm);
            console.log('Data array:', data);
            
            currentSearchTerm = searchTerm;
            searchMatches = [];
            currentMatchIndex = -1;
            
            if (!searchTerm) {
                clearSearchHighlights();
                updateSearchStats();
                return;
            }
            
            // Clear previous highlights
            clearSearchHighlights();
            
            try {
                for (let row = 0; row < data.length; row++) {
                    for (let col = 0; col < data[row].length; col++) {
                        const cellValue = String(data[row][col] || '');
                        let isMatch = false;
                        
                        if (cellValue) { // Only check non-empty cells
                            if (isFuzzy) {
                                isMatch = fuzzyMatch(cellValue, searchTerm, isCaseSensitive);
                            } else if (isRegex) {
                                const flags = isCaseSensitive ? 'g' : 'gi';
                                const regex = new RegExp(searchTerm, flags);
                                isMatch = regex.test(cellValue);
                            } else {
                                const haystack = isCaseSensitive ? cellValue : cellValue.toLowerCase();
                                const needle = isCaseSensitive ? searchTerm : searchTerm.toLowerCase();
                                isMatch = haystack.includes(needle);
                            }
                            
                            if (isMatch) {
                                console.log(`Found match at [${row},${col}]: "${cellValue}"`);
                                searchMatches.push({ row, col });
                                highlightCell(row, col, searchTerm, isRegex, isCaseSensitive);
                            }
                        }
                    }
                }
                console.log('Total matches found:', searchMatches.length);
            } catch (error) {
                console.error('Search error:', error);
                // Clear invalid regex search
                if (isRegex) {
                    searchInput.style.borderColor = '#ef4444';
                    setTimeout(() => searchInput.style.borderColor = '', 2000);
                }
            }
            
            updateSearchStats();
        }
        
        function fuzzyMatch(text, pattern, caseSensitive = false) {
            if (!caseSensitive) {
                text = text.toLowerCase();
                pattern = pattern.toLowerCase();
            }
            
            let textIndex = 0;
            let patternIndex = 0;
            
            while (textIndex < text.length && patternIndex < pattern.length) {
                if (text[textIndex] === pattern[patternIndex]) {
                    patternIndex++;
                }
                textIndex++;
            }
            
            return patternIndex === pattern.length;
        }
        
        function highlightCell(row, col, searchTerm, isRegex, isCaseSensitive) {
            console.log(`Attempting to highlight cell [${row},${col}]`);
            const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            console.log('Cell element found:', cellElement);
            if (!cellElement) {
                console.log('Cell element not found for', row, col);
                return;
            }
            
            const cellValue = cellElement.textContent;
            let highlightedText = cellValue;
            console.log('Cell value:', cellValue);
            
            try {
                if (isRegex) {
                    const flags = isCaseSensitive ? 'gi' : 'gi';
                    const regex = new RegExp(`(${searchTerm})`, flags);
                    highlightedText = cellValue.replace(regex, '<span class="highlight">$1</span>');
                } else {
                    const flags = isCaseSensitive ? 'g' : 'gi';
                    const escapedTerm = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`(${escapedTerm})`, flags);
                    highlightedText = cellValue.replace(regex, '<span class="highlight">$1</span>');
                }
                
                cellElement.innerHTML = highlightedText;
                cellElement.classList.add('matched-row');
            } catch (error) {
                console.error('Highlight error:', error);
            }
        }
        
        function clearSearchHighlights() {
            document.querySelectorAll('.highlight').forEach(el => {
                const parent = el.parentNode;
                parent.textContent = parent.textContent;
            });
            document.querySelectorAll('.matched-row').forEach(el => {
                el.classList.remove('matched-row');
            });
        }
        
        function clearSearch() {
            document.getElementById('searchInput').value = '';
            currentSearchTerm = '';
            searchMatches = [];
            currentMatchIndex = -1;
            clearSearchHighlights();
            updateSearchStats();
        }
        
        function handleSearchKeyDown(event) {
            if (event.key === 'Enter') {
                if (event.shiftKey) {
                    navigateSearchResults(-1); // Previous
                } else {
                    navigateSearchResults(1); // Next
                }
                event.preventDefault();
            } else if (event.key === 'Escape') {
                clearSearch();
            }
        }
        
        function navigateSearchResults(direction) {
            if (searchMatches.length === 0) return;
            
            currentMatchIndex += direction;
            if (currentMatchIndex >= searchMatches.length) currentMatchIndex = 0;
            if (currentMatchIndex < 0) currentMatchIndex = searchMatches.length - 1;
            
            const match = searchMatches[currentMatchIndex];
            selectCell(match.row, match.col);
            scrollToCell(match.row, match.col);
            updateSearchStats();
        }
        
        function scrollToCell(row, col) {
            const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (cellElement) {
                cellElement.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
            }
        }
        
        function updateSearchStats() {
            const statsElement = document.getElementById('searchStats');
            if (searchMatches.length === 0) {
                statsElement.textContent = currentSearchTerm ? 'No matches' : '';
            } else {
                const current = currentMatchIndex >= 0 ? currentMatchIndex + 1 : 1;
                statsElement.textContent = `${current} of ${searchMatches.length}`;
            }
        }
        
        // Filter Functions
        function toggleFilterPanel() {
            const panel = document.getElementById('filterPanel');
            const backdrop = document.querySelector('.sidebar-backdrop');
            
            if (panel.classList.contains('show')) {
                panel.classList.remove('show');
                if (backdrop) backdrop.classList.remove('show');
            } else {
                panel.classList.add('show');
                if (backdrop) backdrop.classList.add('show');
                populateColumnFilter();
            }
        }
        
        function initializeFilterPanel() {
            populateColumnFilter();
        }
        
        function populateColumnFilter() {
            const columnSelect = document.getElementById('columnFilter');
            columnSelect.innerHTML = '<option value="">All columns</option>';
            
            columnNames.forEach((name, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Column ${name}`;
                columnSelect.appendChild(option);
            });
        }
        
        function applyFilters() {
            // Get filter values
            appliedFilters.column = document.getElementById('columnFilter').value;
            appliedFilters.rowFrom = parseInt(document.getElementById('rowFromFilter').value) || null;
            appliedFilters.rowTo = parseInt(document.getElementById('rowToFilter').value) || null;
            appliedFilters.keywords = document.getElementById('keywordFilter').value
                .split(',').map(k => k.trim()).filter(k => k);
            appliedFilters.excludeKeywords = document.getElementById('excludeFilter').value
                .split(',').map(k => k.trim()).filter(k => k);
            appliedFilters.lengthOperator = document.getElementById('lengthOperator').value;
            appliedFilters.lengthValue = parseInt(document.getElementById('lengthValue').value) || null;
            appliedFilters.emptyFilter = document.getElementById('emptyFilter').value;
            
            // Clear previous filters
            filteredRows.clear();
            document.querySelectorAll('.filtered-row').forEach(el => {
                el.classList.remove('filtered-row');
            });
            
            // Apply filters
            for (let row = 0; row < data.length; row++) {
                if (!passesFilters(row)) {
                    filteredRows.add(row);
                    // Mark row as filtered
                    for (let col = 0; col < data[row].length; col++) {
                        const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        if (cellElement) {
                            cellElement.closest('tr').classList.add('filtered-row');
                        }
                    }
                }
            }
            
            // Re-run search on filtered results
            if (currentSearchTerm) {
                performSearch();
            }
        }
        
        function passesFilters(row) {
            // Row range filter
            if (appliedFilters.rowFrom !== null && row + 1 < appliedFilters.rowFrom) return false;
            if (appliedFilters.rowTo !== null && row + 1 > appliedFilters.rowTo) return false;
            
            // Get cells to check
            let cellsToCheck = [];
            if (appliedFilters.column !== '') {
                const colIndex = parseInt(appliedFilters.column);
                cellsToCheck = [data[row][colIndex] || ''];
            } else {
                cellsToCheck = data[row];
            }
            
            // Check each relevant cell
            for (const cellValue of cellsToCheck) {
                const cellText = String(cellValue || '').toLowerCase();
                
                // Empty filter
                if (appliedFilters.emptyFilter === 'empty' && cellText.trim() !== '') return false;
                if (appliedFilters.emptyFilter === 'nonempty' && cellText.trim() === '') return false;
                
                // Length filter
                if (appliedFilters.lengthValue !== null && appliedFilters.lengthOperator) {
                    const length = cellText.length;
                    switch (appliedFilters.lengthOperator) {
                        case 'gt': if (length <= appliedFilters.lengthValue) return false; break;
                        case 'lt': if (length >= appliedFilters.lengthValue) return false; break;
                        case 'eq': if (length !== appliedFilters.lengthValue) return false; break;
                    }
                }
                
                // Keyword filter (at least one keyword must be present)
                if (appliedFilters.keywords.length > 0) {
                    const hasKeyword = appliedFilters.keywords.some(keyword => 
                        cellText.includes(keyword.toLowerCase()));
                    if (!hasKeyword) return false;
                }
                
                // Exclude keywords (none should be present)
                if (appliedFilters.excludeKeywords.length > 0) {
                    const hasExcluded = appliedFilters.excludeKeywords.some(keyword => 
                        cellText.includes(keyword.toLowerCase()));
                    if (hasExcluded) return false;
                }
            }
            
            return true;
        }
        
        function clearFilters() {
            // Reset form
            document.getElementById('columnFilter').value = '';
            document.getElementById('rowFromFilter').value = '';
            document.getElementById('rowToFilter').value = '';
            document.getElementById('keywordFilter').value = '';
            document.getElementById('excludeFilter').value = '';
            document.getElementById('lengthOperator').value = 'gt';
            document.getElementById('lengthValue').value = '';
            document.getElementById('emptyFilter').value = '';
            
            // Clear applied filters
            appliedFilters = {
                column: '', rowFrom: null, rowTo: null, keywords: [], excludeKeywords: [],
                lengthOperator: '', lengthValue: null, emptyFilter: ''
            };
            filteredRows.clear();
            
            // Remove visual filters
            document.querySelectorAll('.filtered-row').forEach(el => {
                el.classList.remove('filtered-row');
            });
            
            // Re-run search
            if (currentSearchTerm) {
                performSearch();
            }
        }
        
        function exportFilteredData() {
            const filteredData = [];
            
            // Add headers
            const headers = columnNames.slice(0, data[0] ? data[0].length : 15);
            filteredData.push(headers);
            
            // Add non-filtered rows
            for (let row = 0; row < data.length; row++) {
                if (!filteredRows.has(row) && data[row].some(cell => cell !== '')) {
                    filteredData.push(data[row]);
                }
            }
            
            // Convert to CSV and download
            const csv = filteredData.map(row => 
                row.map(cell => {
                    const cellStr = String(cell || '');
                    return cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n') 
                        ? `"${cellStr.replace(/"/g, '""')}"` 
                        : cellStr;
                }).join(',')
            ).join('\n');
            
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'filtered_data.csv';
            link.click();
        }

        function exportToExcel() {
            const filteredData = [];
            
            // Add headers with quality indicators columns
            const headers = columnNames.slice(0, data[0] ? data[0].length : 15);
            const enhancedHeaders = [...headers, 'Confidence Level', 'Evidence Strength', 'Quality Score'];
            filteredData.push(enhancedHeaders);
            
            // Add non-filtered rows with metadata
            for (let row = 0; row < data.length; row++) {
                if (!filteredRows.has(row) && data[row].some(cell => cell !== '')) {
                    const rowData = [...data[row]];
                    
                    // Check if this row has any hierarchical coding metadata
                    let hasMetadata = false;
                    let confidence = '';
                    let evidence = '';
                    let qualityScore = '';
                    
                    for (let col = 0; col < rowData.length; col++) {
                        const cellKey = `${row}-${col}`;
                        if (cellMetadata[cellKey]) {
                            hasMetadata = true;
                            confidence = cellMetadata[cellKey].confidence || '';
                            evidence = cellMetadata[cellKey].evidence || '';
                            
                            // Calculate quality score based on confidence and evidence
                            const confidenceScore = confidence === 'High' ? 3 : confidence === 'Medium' ? 2 : confidence === 'Low' ? 1 : 0;
                            const evidenceScore = evidence === 'Strong' ? 3 : evidence === 'Moderate' ? 2 : evidence === 'Weak' ? 1 : 0;
                            qualityScore = confidenceScore && evidenceScore ? `${(confidenceScore + evidenceScore) / 2}/3` : '';
                            break; // Use first metadata found for this row
                        }
                    }
                    
                    // Add metadata columns
                    rowData.push(confidence, evidence, qualityScore);
                    filteredData.push(rowData);
                }
            }
            
            // Create workbook and worksheet
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(filteredData);
            
            // Set column widths
            const colWidths = enhancedHeaders.map((header, index) => {
                if (index >= headers.length) return { wch: 15 }; // Quality indicator columns
                return { wch: Math.max(header.length, 20) };
            });
            ws['!cols'] = colWidths;
            
            // Style the header row
            const headerStyle = {
                fill: { fgColor: { rgb: "4F46E5" } },
                font: { color: { rgb: "FFFFFF" }, bold: true },
                alignment: { horizontal: "center" }
            };
            
            // Apply header styling
            for (let col = 0; col < enhancedHeaders.length; col++) {
                const cellRef = XLSX.utils.encode_cell({ r: 0, c: col });
                if (!ws[cellRef]) ws[cellRef] = {};
                ws[cellRef].s = headerStyle;
            }
            
            // Style quality indicator columns with conditional formatting
            for (let row = 1; row < filteredData.length; row++) {
                // Confidence column styling
                const confidenceCol = headers.length;
                const confidenceCellRef = XLSX.utils.encode_cell({ r: row, c: confidenceCol });
                if (ws[confidenceCellRef] && ws[confidenceCellRef].v) {
                    const confidence = ws[confidenceCellRef].v;
                    let fillColor = "FFFFFF";
                    if (confidence === 'High') fillColor = "16A34A";
                    else if (confidence === 'Medium') fillColor = "EAB308";
                    else if (confidence === 'Low') fillColor = "DC2626";
                    
                    ws[confidenceCellRef].s = {
                        fill: { fgColor: { rgb: fillColor } },
                        font: { color: { rgb: confidence === 'High' ? "FFFFFF" : "000000" } },
                        alignment: { horizontal: "center" }
                    };
                }
                
                // Evidence column styling
                const evidenceCol = headers.length + 1;
                const evidenceCellRef = XLSX.utils.encode_cell({ r: row, c: evidenceCol });
                if (ws[evidenceCellRef] && ws[evidenceCellRef].v) {
                    const evidence = ws[evidenceCellRef].v;
                    let fillColor = "FFFFFF";
                    if (evidence === 'Strong') fillColor = "059669";
                    else if (evidence === 'Moderate') fillColor = "D97706";
                    else if (evidence === 'Weak') fillColor = "B91C1C";
                    
                    ws[evidenceCellRef].s = {
                        fill: { fgColor: { rgb: fillColor } },
                        font: { color: { rgb: evidence === 'Strong' ? "FFFFFF" : "000000" } },
                        alignment: { horizontal: "center" }
                    };
                }
            }
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, "Qualitative Analysis");
            
            // Generate filename with timestamp
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `qualitative_analysis_${timestamp}.xlsx`;
            
            // Download the file
            XLSX.writeFile(wb, filename);
        }
        
        // Test function for debugging
        function testSearch() {
            console.log('=== TESTING SEARCH ===');
            alert('Testing search functionality - check browser console for details');
            
            console.log('Current data:', data);
            console.log('Available cells with data-row attributes:');
            const cells = document.querySelectorAll('[data-row]');
            console.log('Found', cells.length, 'cells with data-row');
            
            // Check if we have test data
            const hasData = data.some(row => row.some(cell => cell && cell.trim()));
            console.log('Has test data:', hasData);
            
            if (!hasData) {
                console.log('No data found, re-initializing...');
                initSpreadsheet();
            }
            
            cells.forEach((cell, index) => {
                if (index < 10) { // Show first 10
                    console.log(`Cell [${cell.getAttribute('data-row')},${cell.getAttribute('data-col')}]: "${cell.textContent}"`);
                }
            });
            
            // Test search for 'Sarah'
            console.log('Setting search term to "Sarah"');
            document.getElementById('searchInput').value = 'Sarah';
            performSearch();
            
            // Show alert with results
            setTimeout(() => {
                const stats = document.getElementById('searchStats').textContent;
                alert(`Search completed. Results: ${stats}. Check console for details.`);
            }, 100);
        }

        // Horizontal scroll function
        function scrollHorizontal(amount) {
            const spreadsheetScroll = document.getElementById('spreadsheetScroll');
            if (!spreadsheetScroll) {
                console.error('Element with id "spreadsheetScroll" not found');
                return;
            }
            spreadsheetScroll.scrollLeft += amount;
        }

        // Vertical scroll function
        function scrollVertical(amount) {
            const spreadsheetScroll = document.getElementById('spreadsheetScroll');
            spreadsheetScroll.scrollTop += amount;
        }

        // Generate column names (A, B, C, etc.)
        function getColumnName(index) {
            let result = '';
            let num = index;
            while (num >= 0) {
                result = String.fromCharCode(65 + (num % 26)) + result;
                num = Math.floor(num / 26) - 1;
            }
            return result;
        }

        // Render the spreadsheet
        function renderSpreadsheet() {
            const scrollContainer = document.getElementById('spreadsheetScroll');
            const savedScrollLeft = scrollContainer ? scrollContainer.scrollLeft : 0;
            const savedScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
            
            const headerRow = document.getElementById('headerRow');
            const body = document.getElementById('spreadsheetBody');
            
            // Clear existing content
            headerRow.innerHTML = '<th class="row-header"></th>';
            body.innerHTML = '';

            // Generate headers
            for (let i = 0; i < 15; i++) {
                const th = document.createElement('th');
                th.className = 'column-header';
                
                const input = document.createElement('input');
                input.value = columnNames[i] || getColumnName(i);
                input.onblur = (e) => updateColumnName(i, e.target.value);
                input.onkeypress = (e) => {
                    if (e.key === 'Enter') {
                        e.target.blur();
                    }
                };
                input.onclick = (e) => {
                    e.stopPropagation();
                    openColumnInstructions(i);
                };
                
                th.appendChild(input);
                headerRow.appendChild(th);
            }

            // Generate rows
            for (let row = 0; row < 30; row++) {
                const tr = document.createElement('tr');
                
                // Row header
                const rowHeader = document.createElement('td');
                rowHeader.className = 'row-header frozen-column';
                rowHeader.textContent = row + 1;
                tr.appendChild(rowHeader);

                // Data cells
                for (let col = 0; col < 15; col++) {
                    const td = document.createElement('td');
                    td.className = 'cell';
                    td.setAttribute('data-row', row);
                    td.setAttribute('data-col', col);
                    
                    // Check if this column has instructions
                    if (columnInstructions[col]) {
                        td.classList.add('has-instructions');
                        
                        // Add hierarchical coding visual indicators
                        if (columnInstructions[col].hierarchicalType) {
                            td.classList.add('hierarchical-' + columnInstructions[col].hierarchicalType);
                            td.classList.add('hierarchical-coding');
                        }
                        
                        // Add action buttons
                        const actions = document.createElement('div');
                        actions.className = 'cell-actions';
                        
                        const regenerateBtn = document.createElement('button');
                        regenerateBtn.className = 'cell-action-btn';
                        regenerateBtn.textContent = 'üîÑ';
                        regenerateBtn.title = 'Regenerate';
                        regenerateBtn.onclick = (e) => {
                            e.stopPropagation();
                            regenerateCell(row, col);
                        };
                        
                        const editBtn = document.createElement('button');
                        editBtn.className = 'cell-action-btn';
                        editBtn.textContent = '‚öôÔ∏è';
                        editBtn.title = 'Edit configuration';
                        editBtn.onclick = (e) => {
                            e.stopPropagation();
                            openColumnInstructions(col);
                        };
                        
                        actions.appendChild(regenerateBtn);
                        actions.appendChild(editBtn);
                        td.appendChild(actions);
                    }
                    
                    td.onclick = () => selectCell(row, col);
                    td.ondblclick = () => editCell(row, col);
                    
                    const cellValue = data[row][col] || '';
                    const cellKey = `${row}-${col}`;
                    const metadata = cellMetadata[cellKey];
                    
                    // Create cell content with confidence and evidence indicators
                    if (metadata && cellValue) {
                        const contentDiv = document.createElement('div');
                        contentDiv.style.position = 'relative';
                        
                        // Main content
                        const contentSpan = document.createElement('span');
                        contentSpan.textContent = cellValue;
                        contentDiv.appendChild(contentSpan);
                        
                        // Confidence indicator (small colored dot)
                        const confidenceIndicator = document.createElement('div');
                        confidenceIndicator.style.position = 'absolute';
                        confidenceIndicator.style.top = '2px';
                        confidenceIndicator.style.right = '2px';
                        confidenceIndicator.style.width = '8px';
                        confidenceIndicator.style.height = '8px';
                        confidenceIndicator.style.borderRadius = '50%';
                        confidenceIndicator.style.backgroundColor = getConfidenceColor(metadata.confidence);
                        confidenceIndicator.title = `Confidence: ${metadata.confidence} | Evidence: ${metadata.evidence}`;
                        contentDiv.appendChild(confidenceIndicator);
                        
                        // Evidence strength indicator (small text)
                        const evidenceIndicator = document.createElement('div');
                        evidenceIndicator.style.position = 'absolute';
                        evidenceIndicator.style.bottom = '1px';
                        evidenceIndicator.style.right = '2px';
                        evidenceIndicator.style.fontSize = '8px';
                        evidenceIndicator.style.color = '#6b7280';
                        evidenceIndicator.style.lineHeight = '1';
                        evidenceIndicator.textContent = getEvidenceIndicator(metadata.evidence);
                        evidenceIndicator.title = `Evidence Strength: ${metadata.evidence}`;
                        contentDiv.appendChild(evidenceIndicator);
                        
                        td.appendChild(contentDiv);
                        td.title = `${cellValue}\n\nConfidence: ${metadata.confidence}\nEvidence: ${metadata.evidence}\nType: ${metadata.hierarchicalType || 'N/A'}`;
                        
                        // Add confidence-based border styling
                        if (metadata.confidence === 'High') {
                            td.style.borderLeft = '3px solid #16a34a';
                        } else if (metadata.confidence === 'Low') {
                            td.style.borderLeft = '3px solid #dc2626';
                        }
                    } else {
                        td.textContent = cellValue;
                        td.title = cellValue; // Show full text on hover
                    }
                    
                    td.style.whiteSpace = 'pre-wrap'; // Allow text wrapping
                    
                    tr.appendChild(td);
                }
                
                body.appendChild(tr);
            }
            
            // Restore scroll position after re-render
            if (scrollContainer) {
                scrollContainer.scrollLeft = savedScrollLeft;
                scrollContainer.scrollTop = savedScrollTop;
            }
        }

        // Select a cell
        function selectCell(row, col) {
            // Remove previous selection
            document.querySelectorAll('.cell.selected').forEach(cell => {
                cell.classList.remove('selected');
            });
            
            // Add selection to new cell
            const cells = document.querySelectorAll('.cell');
            const cellIndex = row * 15 + col;
            cells[cellIndex].classList.add('selected');
            
            selectedCell = { row, col };
            document.getElementById('selectedCell').textContent = `${getColumnName(col)}${row + 1}`;
            document.getElementById('formulaInput').value = data[row][col] || '';
        }

        // Edit a cell
        function editCell(row, col) {
            const cells = document.querySelectorAll('.cell');
            const cellIndex = row * 15 + col;
            const cell = cells[cellIndex];
            
            const input = document.createElement('input');
            input.value = data[row][col] || '';
            input.onblur = () => saveCellEdit(row, col, input.value);
            input.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    saveCellEdit(row, col, input.value);
                }
            };
            
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
        }

        // Save cell edit
        function saveCellEdit(row, col, value) {
            data[row][col] = value;
            renderSpreadsheet();
            selectCell(row, col);
        }

        // Handle formula bar key press
        function handleFormulaKeyPress(event) {
            if (event.key === 'Enter' && selectedCell.row >= 0) {
                const value = document.getElementById('formulaInput').value;
                saveCellEdit(selectedCell.row, selectedCell.col, value);
            }
        }

        // Show config modal
        function showConfig() {
            document.getElementById('apiKeyInput').value = apiKey;
            document.getElementById('serperKeyInput').value = serperKey;
            document.getElementById('configModal').style.display = 'block';
        }

        // Close config modal
        function closeConfig() {
            document.getElementById('configModal').style.display = 'none';
        }

        // Save config
        function saveConfig() {
            apiKey = document.getElementById('apiKeyInput').value;
            serperKey = document.getElementById('serperKeyInput').value;
            localStorage.setItem('openai_api_key', apiKey);
            localStorage.setItem('serper_api_key', serperKey);
            closeConfig();
            
            // Test Serper API if key was provided
            if (serperKey) {
                testSerperAPI();
            }
        }

        // Test Serper API functionality
        async function testSerperAPI() {
            if (!serperKey) {
                console.log('No Serper API key available for testing');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/test-search?query=test`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Serper-Key': serperKey
                    }
                });
                
                const result = await response.json();
                console.log('Serper API test result:', result);
                
                if (result.error) {
                    console.error('Serper API test failed:', result.error);
                } else {
                    console.log('Serper API test successful');
                }
            } catch (error) {
                console.error('Error testing Serper API:', error);
            }
        }

        // Show examples modal
        function showExamples() {
            document.getElementById('examplesModal').style.display = 'block';
        }

        // Close examples modal
        function closeExamples() {
            document.getElementById('examplesModal').style.display = 'none';
        }

        // Load example data
        function loadExample(type) {
            if (type === 'classification') {
                columnNames = ['Review', 'Classification', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
                columnInstructions = {
                    1: {
                        instruction: 'Classify this movie review as positive, negative, or neutral. Answer with one word only.\n\nReview: {{column}}',
                        sourceColumn: 0
                    }
                };
                data = [
                    [],
                    ["This movie was absolutely fantastic! Great acting and storyline.", ""],
                    ["Boring and predictable. Waste of time.", ""],
                    ["It was okay, nothing special but not terrible either.", ""],
                    ...Array(26).fill().map(() => Array(15).fill(''))
                ];
            } else if (type === 'extraction') {
                columnNames = ['News Article', 'People Mentioned', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
                columnInstructions = {
                    1: {
                        instruction: 'Extract all person names mentioned in this text. List them separated by commas. Answer only with the names.\n\nText: {{column}}',
                        sourceColumn: 0
                    }
                };
                data = [
                    [],
                    ["President Biden met with Chancellor Merkel and Prime Minister Johnson yesterday.", ""],
                    ["The meeting between Elon Musk and Tim Cook was scheduled for next week.", ""],
                    ["Taylor Swift announced her new album during an interview with Oprah Winfrey.", ""],
                    ...Array(26).fill().map(() => Array(15).fill(''))
                ];
            } else if (type === 'cleaning') {
                columnNames = ['Raw Data', 'Cleaned Data', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
                columnInstructions = {
                    1: {
                        instruction: 'Clean this text: proper capitalization, remove special characters, format as "Name - Title". Answer with cleaned text only.\n\nRaw data: {{column}}',
                        sourceColumn: 0
                    }
                };
                data = [
                    [],
                    ["john DOE (ceo)", ""],
                    ["JANE smith - marketing director", ""],
                    ["Bob Johnson || Sales Manager", ""],
                    ...Array(26).fill().map(() => Array(15).fill(''))
                ];
            } else if (type === 'entities') {
                columnNames = ['News Text', 'Entities Found', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
                columnInstructions = {
                    1: {
                        instruction: 'Extract named entities from the following text.\n\nRequirements:\n- Find: People, Organizations, Locations, Products\n- Format: "Type: Name" (e.g., "Person: John Smith")\n- List each entity on a new line\n- Return "None found" if no entities exist\n\nText: {{column}}',
                        sourceColumn: 0
                    }
                };
                data = [
                    [],
                    ["Apple Inc. announced their latest iPhone at an event in Cupertino, California, with CEO Tim Cook presenting.", ""],
                    ["Microsoft and Google are partnering with OpenAI to advance artificial intelligence research in Seattle.", ""],
                    ["The United Nations meeting in Geneva discussed climate policies with representatives from China and Brazil.", ""],
                    ...Array(26).fill().map(() => Array(15).fill(''))
                ];
            } else if (type === 'keywords') {
                columnNames = ['Product Description', 'Keywords', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
                columnInstructions = {
                    1: {
                        instruction: 'Extract the most important keywords and key phrases from the following text.\n\nRequirements:\n- Focus on main topics, entities, and concepts\n- Return 3-7 keywords maximum\n- Use comma-separated format\n- Prioritize nouns and significant terms\n\nText: {{column}}',
                        sourceColumn: 0
                    }
                };
                data = [
                    [],
                    ["Premium wireless noise-cancelling headphones with 30-hour battery life and crystal-clear audio quality for audiophiles", ""],
                    ["Ergonomic office chair with lumbar support, adjustable height, and breathable mesh fabric for comfortable work sessions", ""],
                    ["Smart fitness tracker with heart rate monitoring, sleep tracking, GPS, and waterproof design for active lifestyles", ""],
                    ...Array(26).fill().map(() => Array(15).fill(''))
                ];
            } else if (type === 'ideas') {
                columnNames = ['Product Feature', 'Marketing Ideas', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
                columnInstructions = {
                    1: {
                        instruction: 'Generate 3-5 creative ideas or suggestions based on the following input.\n\nRequirements:\n- Provide practical, actionable ideas\n- Format as numbered list\n- Keep each idea concise (1 sentence)\n- Focus on innovative solutions\n\nInput: {{column}}',
                        sourceColumn: 0
                    }
                };
                data = [
                    [],
                    ["Eco-friendly packaging made from recycled materials", ""],
                    ["AI-powered customer support chatbot", ""],
                    ["24/7 same-day delivery service", ""],
                    ...Array(26).fill().map(() => Array(15).fill(''))
                ];
            } else if (type === 'websearch') {
                columnNames = ['Company/Topic', 'Web Research', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
                columnInstructions = {
                    1: {
                        instruction: 'Search the web for information about {{column}} and provide a comprehensive summary of the most relevant and current information found.',
                        sourceColumn: 0
                    }
                };
                data = [
                    [],
                    ["Tesla stock price", ""],
                    ["Climate change latest news", ""],
                    ["AI developments 2024", ""],
                    ...Array(26).fill().map(() => Array(15).fill(''))
                ];
            }
            
            renderSpreadsheet();
            closeExamples();
        }

        // Clear sheet
        function clearSheet() {
            data = Array(30).fill().map(() => Array(15).fill(''));
            columnNames = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'];
            columnInstructions = {};
            renderSpreadsheet();
            hideError();
        }

        // Show error
        function showError(message) {
            document.getElementById('error').textContent = message;
            document.getElementById('error').style.display = 'block';
        }

        // Hide error
        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        // Process AI functions (legacy function - now uses column instructions)
        async function runHFFunctions() {
            await processColumnInstructions();
        }

        // Column instruction functions
        function updateColumnName(colIndex, name) {
            columnNames[colIndex] = name;
            updateSourceColumnOptions();
        }

        function openColumnInstructions(colIndex) {
            currentEditingColumn = colIndex;
            document.getElementById('columnNameInput').value = columnNames[colIndex] || '';
            
            // Show sidebar as fixed overlay with backdrop
            document.getElementById('sidebarBackdrop').classList.add('show');
            document.getElementById('sidebar').classList.add('show');
            
            // Update source column options
            updateSourceColumnOptions();
            
            // Load existing instructions if any
            const existing = columnInstructions[colIndex];
            if (existing) {
                document.getElementById('customInstructionInput').value = existing.instruction || '';
                document.getElementById('sourceColumnSelect').value = existing.sourceColumn || '';
            } else {
                document.getElementById('customInstructionInput').value = '';
                document.getElementById('sourceColumnSelect').value = '';
            }
            
            updatePreview();
        }

        function updateSourceColumnOptions() {
            const select = document.getElementById('sourceColumnSelect');
            select.innerHTML = '<option value="">Select column to reference</option>';
            
            columnNames.forEach((name, index) => {
                if (index !== currentEditingColumn) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = name;
                    select.appendChild(option);
                }
            });
        }

        function selectTemplate(template) {
            // Remove previous selection
            document.querySelectorAll('.instruction-template').forEach(el => {
                el.classList.remove('selected');
            });
            
            // Add selection to clicked template
            event.target.closest('.instruction-template').classList.add('selected');
            selectedTemplate = template;
            
            // Set instruction based on template
            const templates = {
                'translate': 'Translate the following text to French, ensuring grammatical accuracy and natural, human-like phrasing.\n\nRequirements:\n- Maintain original meaning and context\n- Use appropriate cultural references\n- Preserve formatting and tone\n- Return only the translated text\n\nOriginal text: {{column}}',
                
                'extract': 'Extract the most important keywords and key phrases from the following text.\n\nRequirements:\n- Focus on main topics, entities, and concepts\n- Return 3-7 keywords maximum\n- Use comma-separated format\n- Prioritize nouns and significant terms\n\nText: {{column}}',
                
                'summarize': 'Create a concise, clear summary of the following text.\n\nRequirements:\n- Capture the main points and key information\n- Keep summary to 1-3 sentences\n- Maintain objective tone\n- Focus on actionable insights\n\nText: {{column}}',
                
                'sentiment': 'Analyze the sentiment of the following text and classify it.\n\nRequirements:\n- Choose from: Positive, Negative, Neutral\n- Consider overall emotional tone\n- Return only the sentiment classification\n- If mixed sentiment, choose the dominant one\n\nText: {{column}}',
                
                'classify': 'Classify the following text into appropriate categories.\n\nRequirements:\n- Identify the main category or type\n- Return 1-2 category labels maximum\n- Use clear, descriptive category names\n- Focus on content type or subject matter\n\nText: {{column}}',
                
                'entities': 'Extract named entities from the following text.\n\nRequirements:\n- Find: People, Organizations, Locations, Products\n- Format: "Type: Name" (e.g., "Person: John Smith")\n- List each entity on a new line\n- Return "None found" if no entities exist\n\nText: {{column}}',
                
                'clean': 'Clean and standardize the following data entry.\n\nRequirements:\n- Fix capitalization and formatting\n- Remove unnecessary special characters\n- Standardize naming conventions\n- Return clean, professional format\n\nData: {{column}}',
                
                'generate': 'Generate 3-5 creative ideas or suggestions based on the following input.\n\nRequirements:\n- Provide practical, actionable ideas\n- Format as numbered list\n- Keep each idea concise (1 sentence)\n- Focus on innovative solutions\n\nInput: {{column}}',
                
                'moderate': 'Review the following content for appropriateness and safety.\n\nRequirements:\n- Check for: inappropriate language, spam, harmful content\n- Return: "Appropriate" or "Flagged: [reason]"\n- Be objective and professional\n- Consider context and intent\n\nContent: {{column}}',
                
                'language': 'Detect the primary language of the following text.\n\nRequirements:\n- Return the language name in English\n- If multiple languages, return the dominant one\n- Format: "Language: [Name]"\n- Return "Unknown" if cannot determine\n\nText: {{column}}',
                
                'websearch': 'Search the web for information about {{column}} and provide a comprehensive summary of the most relevant and current information found.',
                
                'hierarchical': 'You are a qualitative research analyst performing systematic thematic analysis. Extract hierarchical codes from this verbatim using established qualitative research methodology.\n\nANALYSIS FRAMEWORK:\n- HIGH-LEVEL CODE: Identify the overarching theme or conceptual domain\n- MID-LEVEL CODE: Identify the specific category or subcategory within the theme\n- LOW-LEVEL CODE: Identify the most granular aspect or specific manifestation\n\nOUTPUT FORMAT: "High: [theme] | Mid: [category] | Low: [specific] | Confidence: [High/Medium/Low] | Evidence: [Strong/Moderate/Weak]"\n\nQUALITY CRITERIA:\n- Codes should be mutually exclusive and exhaustive\n- Use descriptive, research-appropriate terminology\n- Ensure hierarchical coherence (each level should logically nest within the higher level)\n- Base confidence on clarity and specificity of evidence in text\n\nEXEMPLARS:\n- High: Consumer Health Consciousness | Mid: Nutritional Decision-Making | Low: Caloric Intake Management | Confidence: High | Evidence: Strong\n- High: Convenience Orientation | Mid: Time-Optimization Behaviors | Low: Ready-Meal Consumption | Confidence: High | Evidence: Strong\n- High: Brand Trust Dynamics | Mid: Reputation-Based Selection | Low: Established Brand Preference | Confidence: Medium | Evidence: Moderate\n\nVERBATIM: {{column}}',
                
                'custom': ''
            };
            
            document.getElementById('customInstructionInput').value = templates[template] || '';
            
            // Show/hide hierarchical config panel and quality legend
            const hierarchicalConfig = document.getElementById('hierarchicalConfig');
            const qualityLegend = document.getElementById('qualityLegend');
            if (template === 'hierarchical') {
                hierarchicalConfig.style.display = 'block';
                qualityLegend.style.display = 'block';
            } else {
                hierarchicalConfig.style.display = 'none';
                qualityLegend.style.display = 'none';
            }
            
            updatePreview();
        }

        function updatePreview() {
            const instruction = document.getElementById('customInstructionInput').value;
            const sourceColIndex = document.getElementById('sourceColumnSelect').value;
            
            if (instruction && sourceColIndex !== '') {
                const sourceColName = columnNames[sourceColIndex];
                const preview = instruction.replace(/\{\{column\}\}/g, `{{${sourceColName}}}`);
                document.getElementById('instructionPreview').textContent = preview;
            } else {
                document.getElementById('instructionPreview').textContent = 'Select a template and source column to see preview';
            }
        }

        async function applyInstructions() {
            const colName = document.getElementById('columnNameInput').value;
            const instruction = document.getElementById('customInstructionInput').value;
            const sourceColIndex = document.getElementById('sourceColumnSelect').value;
            
            if (colName) {
                columnNames[currentEditingColumn] = colName;
            }
            
            // Handle hierarchical coding setup
            if (selectedTemplate === 'hierarchical' && sourceColIndex !== '') {
                const highLevelName = document.getElementById('highLevelName').value || 'Theme';
                const midLevelName = document.getElementById('midLevelName').value || 'Category';
                const lowLevelName = document.getElementById('lowLevelName').value || 'Specific Code';
                
                // Set up three columns for hierarchical coding
                const baseCol = currentEditingColumn;
                
                // Ensure we have enough columns
                while (columnNames.length < baseCol + 3) {
                    columnNames.push(`Col${columnNames.length + 1}`);
                }
                
                // Set column names
                columnNames[baseCol] = highLevelName;
                columnNames[baseCol + 1] = midLevelName;
                columnNames[baseCol + 2] = lowLevelName;
                
                // Create instructions for each level - simplified approach
                columnInstructions[baseCol] = {
                    instruction: 'You are a qualitative research analyst performing systematic thematic analysis. Extract the HIGH-LEVEL code (overarching theme) from this verbatim.\n\nANALYSIS CRITERIA:\n- Identify the broadest conceptual domain or thematic category\n- Use established qualitative research terminology\n- Ensure the code captures the main conceptual area without being too granular\n- Provide confidence assessment based on evidence clarity\n\nOUTPUT FORMAT: "[Theme Name] | Confidence: [High/Medium/Low] | Evidence: [Strong/Moderate/Weak]"\n\nEXAMPLES:\n- Consumer Health Consciousness | Confidence: High | Evidence: Strong\n- Convenience Orientation | Confidence: High | Evidence: Strong\n- Brand Trust Dynamics | Confidence: Medium | Evidence: Moderate\n\nVERBATIM: {{column}}',
                    sourceColumn: parseInt(sourceColIndex),
                    hierarchicalType: 'high'
                };
                
                columnInstructions[baseCol + 1] = {
                    instruction: 'You are a qualitative research analyst performing systematic thematic analysis. Extract the MID-LEVEL code (specific category) from this verbatim.\n\nANALYSIS CRITERIA:\n- Identify the specific category or subcategory within the broader theme\n- The code should be more granular than the high-level theme but broader than specific behaviors\n- Use precise qualitative research terminology\n- Assess confidence based on textual evidence clarity\n\nOUTPUT FORMAT: "[Category Name] | Confidence: [High/Medium/Low] | Evidence: [Strong/Moderate/Weak]"\n\nEXAMPLES:\n- Nutritional Decision-Making | Confidence: High | Evidence: Strong\n- Time-Optimization Behaviors | Confidence: High | Evidence: Strong\n- Reputation-Based Selection | Confidence: Medium | Evidence: Moderate\n\nVERBATIM: {{column}}',
                    sourceColumn: parseInt(sourceColIndex),
                    hierarchicalType: 'mid'
                };
                
                columnInstructions[baseCol + 2] = {
                    instruction: 'You are a qualitative research analyst performing systematic thematic analysis. Extract the LOW-LEVEL code (specific manifestation) from this verbatim.\n\nANALYSIS CRITERIA:\n- Identify the most granular aspect, behavior, or specific manifestation\n- This should be the most concrete and specific level of analysis\n- Use precise, behaviorally-specific terminology\n- Ensure the code represents an observable or identifiable phenomenon\n\nOUTPUT FORMAT: "[Specific Code] | Confidence: [High/Medium/Low] | Evidence: [Strong/Moderate/Weak]"\n\nEXAMPLES:\n- Caloric Intake Management | Confidence: High | Evidence: Strong\n- Ready-Meal Consumption | Confidence: High | Evidence: Strong\n- Established Brand Preference | Confidence: Medium | Evidence: Moderate\n\nVERBATIM: {{column}}',
                    sourceColumn: parseInt(sourceColIndex),
                    hierarchicalType: 'low'
                };
                
                // Track this as a hierarchical set
                hierarchicalCodeSets[baseCol] = {
                    highCol: baseCol,
                    midCol: baseCol + 1,
                    lowCol: baseCol + 2,
                    sourceCol: parseInt(sourceColIndex)
                };
                
                closeSidebar();
                await processColumnInstructions();
                
            } else if (instruction && sourceColIndex !== '') {
                // Standard single-column instruction
                columnInstructions[currentEditingColumn] = {
                    instruction: instruction,
                    sourceColumn: parseInt(sourceColIndex)
                };
                
                closeSidebar();
                await processColumnInstructions();
            } else {
                renderSpreadsheet();
                closeSidebar();
            }
        }

        function closeSidebar() {
            document.getElementById('sidebarBackdrop').classList.remove('show');
            document.getElementById('sidebar').classList.remove('show');
            currentEditingColumn = -1;
            selectedTemplate = '';
            
            // Clear template selections
            document.querySelectorAll('.instruction-template').forEach(el => {
                el.classList.remove('selected');
            });
        }

        function addColumn() {
            // Find next available column
            const nextCol = columnNames.findIndex(name => name === getColumnName(columnNames.indexOf(name)));
            if (nextCol === -1) {
                columnNames.push(`Column ${columnNames.length + 1}`);
            }
            openColumnInstructions(columnNames.length - 1);
        }

        // Add event listeners for instruction input updates
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('customInstructionInput').addEventListener('input', updatePreview);
            document.getElementById('sourceColumnSelect').addEventListener('change', updatePreview);
        });

        // Process column instructions using AI
        async function processColumnInstructions() {
            if (!apiKey) {
                showError('Please configure your OpenAI API key first');
                showConfig();
                return;
            }

            hideError();
            document.getElementById('loading').style.display = 'block';

            try {
                // Process columns that have instructions
                for (const [colIndex, instruction] of Object.entries(columnInstructions)) {
                    const col = parseInt(colIndex);
                    const sourceCol = instruction.sourceColumn;
                    
                    // Process each row for this column
                    for (let row = 0; row < data.length; row++) { // Process all rows including first data row
                        const sourceText = data[row][sourceCol] || '';
                        if (!sourceText.trim()) {
                            console.log(`Skipping row ${row + 1} - empty source cell`);
                            continue; // Skip empty cells to save API calls
                        }
                        
                        console.log(`Processing row ${row + 1} with content: "${sourceText.substring(0, 50)}${sourceText.length > 50 ? '...' : ''}"`);
                        const processedInstruction = instruction.instruction.replace(/\{\{column\}\}/g, sourceText);
                        
                        // Call API
                        const headers = { 
                            'Content-Type': 'application/json',
                            'X-API-Key': apiKey
                        };
                        
                        // Add Serper key if available
                        if (serperKey) {
                            headers['X-Serper-Key'] = serperKey;
                        }
                        
                        const response = await fetch(`${API_BASE}/hf`, {
                            method: 'POST',
                            headers: headers,
                            body: JSON.stringify({
                                text: sourceText,
                                model: document.getElementById('modelSelect').value,
                                prompt: processedInstruction
                            })
                        });

                        if (response.ok) {
                            const result = await response.json();
                            const parsed = parseEnhancedResponse(result.result);
                            data[row][col] = parsed.content;
                            
                            // Store metadata
                            const cellKey = `${row}-${col}`;
                            cellMetadata[cellKey] = {
                                confidence: parsed.confidence,
                                evidence: parsed.evidence,
                                hierarchicalType: instruction.hierarchicalType,
                                timestamp: new Date().toISOString()
                            };
                            
                            // Update the display immediately for each processed cell
                            renderSpreadsheet();
                        }
                    }
                }
                
                renderSpreadsheet();

            } catch (error) {
                showError(`Error processing instructions: ${error.message}`);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Refresh all column instructions
        async function refreshAllInstructions() {
            await processColumnInstructions();
        }

        // Regenerate a specific cell
        async function regenerateCell(row, col) {
            if (!apiKey) {
                showError('Please configure your OpenAI API key first');
                showConfig();
                return;
            }

            if (!columnInstructions[col]) {
                return; // No instructions for this column
            }

            hideError();
            document.getElementById('loading').style.display = 'block';

            try {
                const instruction = columnInstructions[col];
                const sourceCol = instruction.sourceColumn;
                const sourceText = data[row][sourceCol] || '';

                if (!sourceText.trim()) {
                    console.log(`Cannot regenerate row ${row + 1} - source cell is empty`);
                    document.getElementById('loading').style.display = 'none';
                    return; // Don't waste API call on empty cell
                }
                
                console.log(`Regenerating cell ${row + 1} with content: "${sourceText.substring(0, 50)}${sourceText.length > 50 ? '...' : ''}"`);
                const processedInstruction = instruction.instruction.replace(/\{\{column\}\}/g, sourceText);
                
                // Call API
                const headers = { 
                    'Content-Type': 'application/json',
                    'X-API-Key': apiKey
                };
                
                // Add Serper key if available
                if (serperKey) {
                    headers['X-Serper-Key'] = serperKey;
                }
                
                const response = await fetch(`${API_BASE}/hf`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        text: sourceText,
                        model: document.getElementById('modelSelect').value,
                        prompt: processedInstruction
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    const parsed = parseEnhancedResponse(result.result);
                    data[row][col] = parsed.content;
                    
                    // Store metadata
                    const cellKey = `${row}-${col}`;
                    cellMetadata[cellKey] = {
                        confidence: parsed.confidence,
                        evidence: parsed.evidence,
                        hierarchicalType: instruction.hierarchicalType,
                        timestamp: new Date().toISOString()
                    };
                    
                    renderSpreadsheet();
                } else {
                    showError(`Error regenerating cell: ${response.statusText}`);
                }
            } catch (error) {
                showError(`Error regenerating cell: ${error.message}`);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Load CSV file
        function loadCSV() {
            document.getElementById('csvFileInput').click();
        }

        // Handle CSV file selection and parsing
        function handleCSVFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    parseCSV(csvContent);
                    hideError();
                } catch (error) {
                    showError(`Error reading CSV file: ${error.message}`);
                }
            };
            reader.readAsText(file);
        }

        // Parse CSV content and populate spreadsheet
        function parseCSV(csvContent) {
            const lines = csvContent.split('\n');
            const parsedData = [];
            
            // Parse each line
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines
                
                const row = parseCSVLine(line);
                parsedData.push(row);
            }
            
            if (parsedData.length === 0) {
                showError('CSV file appears to be empty');
                return;
            }

            // First row becomes column headers
            const headers = parsedData[0];
            for (let i = 0; i < Math.min(headers.length, 15); i++) {
                columnNames[i] = headers[i] || getColumnName(i);
            }
            
            // Fill remaining column names with defaults
            for (let i = headers.length; i < 15; i++) {
                columnNames[i] = getColumnName(i);
            }

            // Initialize data array
            data = Array(30).fill().map(() => Array(15).fill(''));
            
            // Populate data (skip header row)
            for (let rowIdx = 1; rowIdx < parsedData.length && rowIdx <= 30; rowIdx++) {
                const csvRow = parsedData[rowIdx];
                for (let colIdx = 0; colIdx < Math.min(csvRow.length, 15); colIdx++) {
                    data[rowIdx - 1][colIdx] = csvRow[colIdx] || '';
                }
            }

            // Clear any existing column instructions since data structure changed
            columnInstructions = {};
            
            renderSpreadsheet();
        }

        // Parse a single CSV line handling quotes properly
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            let i = 0;

            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Escaped quote
                        current += '"';
                        i += 2;
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                        i++;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    result.push(current);
                    current = '';
                    i++;
                } else {
                    current += char;
                    i++;
                }
            }
            
            // Add the last field
            result.push(current);
            
            return result;
        }

        // Download current sheet data as CSV
        function downloadCSV() {
            // Create CSV content with UTF-8 BOM for better Excel compatibility
            let csvContent = '\uFEFF'; // UTF-8 BOM
            
            // Add headers
            const headers = columnNames.slice(0, 15); // Limit to 15 columns
            csvContent += headers.map(h => formatCSVCell(h)).join(',') + '\r\n';
            
            // Add data rows (filter out completely empty rows)
            for (let row = 0; row < data.length; row++) {
                const rowData = data[row].slice(0, 15); // Limit to 15 columns
                const hasData = rowData.some(cell => cell && cell.toString().trim() !== '');
                
                if (hasData) {
                    const csvRow = rowData.map(cell => formatCSVCell(cell)).join(',');
                    csvContent += csvRow + '\r\n';
                }
            }
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'ai_sheets_data.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Format cell for CSV export with proper escaping and line breaks
        function formatCSVCell(cell) {
            if (cell == null || cell === '') {
                return '""';
            }
            
            let cellStr = cell.toString();
            
            // Replace any double quotes with double double quotes
            cellStr = cellStr.replace(/"/g, '""');
            
            // Handle line breaks - keep them as actual line breaks within quotes
            // This will allow Excel to display multi-line text properly
            cellStr = cellStr.replace(/\n/g, '\n');
            cellStr = cellStr.replace(/\r\n/g, '\n');
            
            // Always wrap in quotes to ensure proper CSV formatting
            return `"${cellStr}"`;
        }

        // Debug function for testing scroll
        function testScroll() {
            const el = document.getElementById('spreadsheetScroll');
            console.log('Testing scroll element:', {
                found: !!el,
                overflowX: el ? getComputedStyle(el).overflowX : 'N/A',
                overflowY: el ? getComputedStyle(el).overflowY : 'N/A',
                scrollWidth: el ? el.scrollWidth : 'N/A',
                clientWidth: el ? el.clientWidth : 'N/A',
                canScrollHorizontally: el ? el.scrollWidth > el.clientWidth : false,
                scrollHeight: el ? el.scrollHeight : 'N/A',
                clientHeight: el ? el.clientHeight : 'N/A',
                canScrollVertically: el ? el.scrollHeight > el.clientHeight : false
            });
            if (el) {
                console.log('Testing horizontal scroll...');
                el.scrollLeft += 300;
                console.log('New scrollLeft:', el.scrollLeft);
            }
        }
        
        // Make functions available globally
        window.scrollHorizontal = scrollHorizontal;
        window.scrollVertical = scrollVertical;
        window.testScroll = testScroll;

        // Initialize on page load
        initSpreadsheet();
    </script>
</body>
</html>